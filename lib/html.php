<?php
// Gaming World 2006 <https://gamingw.net/>
// Â© MIT License

/**
 * Extracts information from the "page_index" value.
 * 
 * This value is generated by SMF and contains the available page number links.
 * 
 * On some pages we cannot generate these links ourselves, so we need to extract information
 * from the one generated by SMF itself.
 */
function extract_page_index_data($page_index, $per_page) {
  // Force utf-8 encoding.
  $doc = new DOMDocument();
  $doc->loadHTML('<?xml encoding="UTF-8">'.$page_index);

  // Specifically what we want is the last item, as we otherwise can't know the last page.
  $nodes = $doc->getElementsByTagName('a');
  $node = $nodes[$nodes->length - 1];

  // If there's no <a> tag, there's no pagination here.
  if ($node === null) {
    return [];
  }

  // Extract the 'start' parameter.
  $url = parse_url($node->getAttribute('href'));
  preg_match('#start=([0-9]+)#', $url['query'], $href);

  // Grab the page number of the last page.
  $last = intval($node->textContent);

  // Similarly, find the <strong>1</strong> (current) page number.
  $nodes = $doc->getElementsByTagName('strong');
  $node = $nodes[0];
  $current = null;
  if ($node !== null) {
    $current = intval(trim($node->textContent));
  }

  return ['last_page_number' => $last, 'last_page_offset' => intval($href[1]), 'per_page' => $per_page, 'current_page_number' => $current];
}

/**
 * Splits up the content of a profile field value.
 * 
 * Profile field values are structured like this:
 * 
 *   <div class="profile_field_item">
 *     <dt>
 *       <div class="profile_field_label">Label</div>
 *       <div class="profile_field_subtext">Additional label subtext</div>
 *     </dt>
 *     <dd class="profile_field_content">
 *       field content
 *     </dd>
 *   </div>
 *   .. additional .profile_field_item divs might exist.
 * 
 * We need "label" in one string, and then all the other html in another string.
 */
function extract_profile_field_data($profile_value) {
  $doc = new DOMDocument();
  $doc->loadHTML('<?xml encoding="UTF-8">'.$profile_value);

  $field_items = find_nodes_by_class($doc, 'profile_field_item');

  // If there are no .profile_field_item divs, assume this has a dt/dd structure.
  if (!count($field_items)) {
    return [extract_profile_field_legacy($profile_value)];
  }

  $items = [];
  foreach ($field_items as $field_item) {
    $field_data = _find_profile_field_item_data($doc->saveHTML($field_item));
    $items[] = $field_data;
  }
  return $items;
}

/**
 * Extracts the profile field item data for a single item.
 * 
 * Called by extract_profile_field_data().
 */
function _find_profile_field_item_data($item_value) {
  $doc = new DOMDocument();
  $doc->loadHTML('<?xml encoding="UTF-8">'.$item_value);

  $label = find_nodes_by_class($doc, 'profile_field_label');
  $subtext = find_nodes_by_class($doc, 'profile_field_subtext');
  $content = find_nodes_by_class($doc, 'profile_field_content');

  return [
    'label' => get_inner_html($label->item(0)),
    'subtext' => get_inner_html($subtext->item(0)),
    'content' => get_inner_html($content->item(0)),
  ];
}

/**
 * Splits up the content of a profile field value.
 * 
 * These values are generated by callbacks. We want to display part of the content
 * in a <th> and another part in a <td>, so we need to split it up into two parts.
 * 
 * Profile field values are structured like this:
 * 
 *   <dt>
 *     <strong>Label</strong>
 *     other html
 *   </dt>
 *   <dd>
 *     other html
 *   </dd>
 * 
 * We need "label" in one string, and then all the other html in another string.
 */
function extract_profile_field_legacy($profile_value) {
  $doc = new DOMDocument();
  $doc->loadHTML('<?xml encoding="UTF-8">'.$profile_value);

  // Initial values for the label and field content.
  $label = '';
  $dt_content = [];
  $dd_content = [];
  
  $dt_nodes = $doc->getElementsByTagName('dt');
  $dt_node = $dt_nodes[$dt_nodes->length - 1];
  
  $dd_nodes = $doc->getElementsByTagName('dd');
  $dd_node = $dd_nodes[$dd_nodes->length - 1];

  $found_label = false;
  foreach ($dt_node->childNodes as $node) {
    // Try to find the first <dt> <strong> item. Save it as the label.
    if ($node->nodeName === 'strong' && !$found_label) {
      $label = trim($node->textContent);
      $found_label = true;
    }
    else {
      $dt_content[] = trim($doc->saveHTML($node));
    }
  }
  foreach ($dd_node->childNodes as $node) {
    $dd_content[] = trim($doc->saveHTML($node));
  }

  $dt_div = '<div class="field_dt">'.trim_br(implode("\n", $dt_content)).'</div>';
  $dd_div = '<div class="field_dd">'.trim_br(implode("\n", $dd_content)).'</div>';

  return [
    'label' => $label,
    'subtext' => '',
    'content' => $dt_div."\n".$dd_div,
  ];
}

/**
 * Trims leading and trailing <br> tags from an HTML segment.
 * 
 * Break tags are always just the "<br>" string if retrieved from DOMDocument->saveHTML().
 */
function trim_br($_html) {
  $html = trim($_html);
  $trim_char = "\u{E064}"; // Private Use Area character.

  // Kinda hackish: replace with a special character and then trim that out.
  $a = str_replace('<br>', $trim_char, $html);
  $b = trim($a, $trim_char);
  $c = str_replace($trim_char, '<br>', $b);

  return $c;
}

/**
 * Returns the first image in an HTML string.
 */
function find_first_image($html) {
  $doc = new DOMDocument();
  $doc->loadHTML('<?xml encoding="UTF-8">'.$html);

  $img_nodes = $doc->getElementsByTagName('img');
  
  if ($img_nodes->length > 0) {
    $first = $img_nodes[0];
    return $first->getAttribute('src');
  }

  return null;
}

/**
 * Retrieves a number of ndoes by classname.
 */
function find_nodes_by_class($doc, $classname, $context = null) {
  $xpath = new DomXPath($doc);
  $nodes = $xpath->query("//*[contains(concat(' ', normalize-space(@class), ' '), ' $classname ')]", $context);
  return $nodes;
}

/**
 * Retrieves the inner HTML of a node.
 */
function get_inner_html($node) {
  $inner = '';
  foreach ($node->childNodes as $child) {
    $inner .= $node->ownerDocument->saveHTML($child);
  }
  return $inner;
}
